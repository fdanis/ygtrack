package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

type templateInfoVar struct {
	Package string
	Type    string
	Entries []templateInfoVarEntry
}

type templateInfoVarEntry struct {
	Name         string
	FormatedName string
}

const templateStr = `
// Code generated by go generate; DO NOT EDIT.
// This file was generated by genvar.go

package {{.Package}}

import (
	"fmt"
)

func printInfoVar(){
	{{range .Entries}} print("{{.FormatedName}}",string({{.Name}}))	
	{{end}}}

func print(name string, val string){
	if val ==""	{
		fmt.Printf("%s: N/A\n",name)	
	} else{
		fmt.Printf("%s: %s\n",name,val)	
	}
}
`

var tmpl = template.Must(template.New("enum").Parse(templateStr))

func main() {
	fname := os.Getenv("GOFILE") // имя файла, из которого вызван go:generate,
	// установлено в переменной окружения $GOFILE
	typ := os.Args[1]

	// получаем AST
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, fname, nil, 0)
	if err != nil {
		panic(err)
	}

	var entries []templateInfoVarEntry
	// итерируемся по всем определениям в корне файла
	for _, d := range f.Decls {
		// ищем блок с переменными
		var gd *ast.GenDecl
		var ok bool
		if gd, ok = d.(*ast.GenDecl); !ok {
			continue
		}
		if gd.Tok != token.VAR {
			continue
		}

		// итерируемся по всем конcтантам в блоке
		for _, s := range gd.Specs {
			vs := s.(*ast.ValueSpec)

			// получаем тип константы
			var it *ast.Ident
			if it, ok = vs.Type.(*ast.Ident); !ok {
				continue
			}
			if it.Name != typ {
				continue
			}

			// получаем имя константы
			var name string
			if len(vs.Names) < 1 {
				continue
			}
			name = vs.Names[0].Name

			// сохраняем собранные данные для последующей передачи в шаблон
			entries = append(entries, templateInfoVarEntry{Name: name, FormatedName: formatVarName(name)})
		}
	}

	if len(entries) == 0 {
		return
	}
	// генерируем код по шаблону
	var buf bytes.Buffer
	err = tmpl.Execute(&buf, templateInfoVar{Package: f.Name.Name, Type: typ, Entries: entries})
	if err != nil {
		panic(err)
	}

	// форматируем код
	bufFmt, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Println(string(buf.Bytes()))
		panic(err)
	}

	// записываем сгенерированный код в файл
	basename := strings.TrimSuffix(fname, filepath.Ext(fname))
	err = os.WriteFile(fmt.Sprintf("%s_methods.go", basename), bufFmt, 0644)
	if err != nil {
		panic(err)
	}
}

func formatVarName(name string) string {
	if name == "" {
		return ""
	}

	result := make([]string, 0)
	r := regexp.MustCompile(`((?:^|[A-Z])(?:[^A-Z]*))`)
	matches := r.FindAllString(name, -1)

	upperName := ""
	for _, v := range matches {
		if len(v) == 1 {
			upperName += v
		} else {
			if upperName != "" {
				result = append(result, upperName)
				upperName = ""
			}

			result = append(result, strings.ToLower(v))
		}
	}
	if upperName != "" {
		result = append(result, upperName)
	}

	if len(result) > 0 {
		result[0] = cases.Title(language.English).String(result[0])
	}

	return strings.Trim(fmt.Sprint(result), "[]")
}
